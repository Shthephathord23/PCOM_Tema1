# Tema 1 - Data Plane Router

Proiectul presupune sa implementez un router IP. In tema sunt trei fisiere mari unde se afla majoritatea codului: `router.cpp`, `router.hpp` si `trie.hpp`. 
`router.cpp` se ocupa de logica de rutare.
`router.hpp` defineste toate tipurile de date si macro-urile de care am nevoie
`trie.hpp` doar implementeaza o trie de care am nevoie pentru longest prefix match in timp mai bun decat liniar. Codul de la trie este reutilizat de la materia SDA din anul I si adaptat putin pentru C++.

Eu am decis sa fac tema in C++ si nu in C, deoarece am incredere mai mare in cum este implementat un `queue` sau un `hash_map` decat implementarile facute de mine la SDA. Totusi nu stiu sa existe `trie` in STL, asa ca am fost nevoit sa il implementez.

---

## Structura fisierelor

### router.cpp

- **Loop-ul principal:**
  Ascultam constant dupa frame-uri de Ethernet si le dirijam in functie de tipul lor. In tema avem de implementat doar pachete IP sau ARP.

- **Initializarea tabelului de rutare si a triei:**  
  - Citim tabelul de rutare cu functia din schelet `read_rtable()`.
  - Construim tria(imi pare rau daca `tria` nu este corect gramatical) din tabelul de rutare folosind `build_trie()` din `trie.hpp`.
  - Dam update la pointer-ul global `trie_root` care este un pointer catre o trie ce se calculeaza pe baza tabelului din `read_rtable()`.

- **Procesarea de pachete:**  
  - **IPv4:**  
    - Verificam header-ul pachetului pentru corectitudine (checksum si TTL).
    - Verificam daca pachetul este destinat noua (din pespectiva router-ului noi = router) sau daca ii dam forward mai departe.
    - Folosim `lookup(trie_root, dest_ip)` ca sa gasim cea mai buna (in sensul longest prefix match) ruta din trie.
    - Daca exista macar o ruta, ne uitam in tabela de arp si daca exista ip-ul next-hop-ului trimitem mai departe, altfel rezolvam si trimitem mai tarziu.
    - Trimitem mesaje ICMP cand apar erori (de pilda Time Excedeed sau unreachable host).
  
  - **ARP:**  
    - Procesam ARP request-uri si ARP reply-uri.
    - Dam update la hashmap-ul care reprezinta memoria permanenta pentru arp table si dam handle la pachete in queue care asteapta pentru un ARP reply.

- **Functii:**  
  Functii precum `send_ipv4_packet()` si `handle_ipv4_packet()`, incapsuleaza detalii despre construirea pachetului si decizia unde sa il trimita.

### router.hpp

- **Structuri:**  
  - Am dat multe typedef-uri si am facut wrappere pentru Ethernet frames, IPv4 packets, ARP packets, si ICMP packets.
  - Am facut si API pentru pachete si header.

- **Macro-uri si functii inline:**  
  - Includem macro-uri (cum ar fi `get_eth_hdr`, `get_ipv4_hdr`, si `get_arp_hdr`) pentru a simplifica parsarea header-elor
  - Contine functii inline pentru a da handle la task-uri ca checksum si byte-order conversions.

---

## How It Works

1. **Tria de rutare:**  
   - Citim tabelul de rutare folosind functia din `lib.h`.
   - `build_trie()` ne face o trie.  
   - Pointer-ul global `trie_root` este folosit pentru IP lookups.

2. **Packet Reception and Handling:**  
   - Bucla principala in `router.cpp` ia frame-uri de la `recv_from_any_link()`.
   - In functie de ether_type din Ethernet frame (IP sau ARP packet), frame-ul este dus la handler-ul bun.
     - Pentru **IPv4 packets**, router-ul verifica header-ul si da forward la pachet folosind trie lookup (dupa ARP resolution daca e nevoie) sau genereaza ICMP error daca pachetul nu poate fi forwardat.
     - Pentru **ARP packets**, router-ul raspunde la ARP requests, updateaza ARP table dupa ce a primit replies, si proceseaza toate pachetele care asteapta un ARP entry.

---

## Conclusion
Folosind o trie binara pentru LPM, router-ul poate sa identifice eficient next hop-ul pentru pachetele de IP.
